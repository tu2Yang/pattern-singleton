1、饿汉式 （启动时就加载，资源浪费 线程安全）
静态成员变量初始化
静态代码块
原理都是在程序启动时，静态资源只会加载一次，以此来保证单例

2、懒汉式 （延迟加载，使用时加载）
静态公用方法new对象（非线程安全）
synchronized修饰静态公用方法new对象（线程安全，效率低）
双重判断，静态公用方法内使用synchronized保护线程安全
静态内部类，在私有静态内部类中创建私有静态属性，再用静态公用方法调用
原理是利用了静态内部类在使用时只能在第一次被调用时创建实例
静态内部类缺陷：反射可能破坏单例，所以需要在私有化构造方法的时候，判断静态内部类是否已经有实例

3、防止反序列化破坏单例
在执行反序列化方法，ObjectInputStream.readObject方法中，会判断反序列对象中是否有readResolve方法，如果有，则返回该方法返回的对象
用反射判断反序列化类中是否有readResolve方法

4、注册式单例
枚举单例 EnumSingleton
枚举类型不可通过反射初始化
枚举单例是最安全的单例模式，天然防止反序列破坏单例
反编译可以看到生成的文件，里面有静态代码块来初始化（饿汉式单例 线程安全）

容器单例 ContainerSingleton
该单例中ConcurrentHashMap的ioc容器是线程安全的，但是getBean方法不是，所以需要用到synchronized(ioc)

5、ThreadLocal单例（注册单例--容器式） 从ThreadLocal中获取
线程内部是单例，但是线程间不是。同一个线程只有一个实例

